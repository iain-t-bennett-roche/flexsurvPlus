---
title: "PSA and correlated endpoints (bootstrap approch)"
author: "Roche"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: references.bib
csl: biomedicine.csl
vignette: >
  %\VignetteIndexEntryFitting parametric survival models in R - uncertainty}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 6
)
```

<style type="text/css">

body{ /* Normal  */
      font-size: 14px;
  }
td {  /* Table  */
  font-size: 10px;
}
h1.title {
  font-size: 38px;
}
h1 { /* Header 1 */
  font-size: 28px;
  }
h2 { /* Header 2 */
    font-size: 22px;
}
h3 { /* Header 3 */
  font-size: 18px;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>

# Introduction

Parametric survival models are often the preferred method of extrapolating
survival data for use in economic models. The National Institute for Health and
Care Excellence (NICE) Decision Support Unit (DSU) technical support document
(TSD) 14 recommends that the Exponential, Weibull, Gompertz, log-logistic, log
normal and Generalized Gamma parametric models should all be
considered.[@latimer2011nice] More recently, NICE also discusses more flexible
models in NICE DSU TSD 21, however, more these models are not in the scope of
this package.[@rutherford2020nice] The Canadian Agency for Drugs and
Technologies in Health (CADTH) additionally specifies that the Gamma
distribution must also be considered. This document therefore details the
characteristics of each of these distributions and demonstrates how the
parameters from each distribution, outputted using the flexsurvPlus package, can be
implemented within an economic model.[@cadth2020]

# Handling uncertainty

The flexsurvPlus package allows the handling of uncertainty in estimates primarily through boot strapping. This enables correlations between different endpoints to be preserved in the excel models. This vignette illustrates this with a simple example.

# Set up packages and data

## Install packages

The following packages are required to run this example:

```{r setup}
library(flexsurvPlus)
library(tibble)
library(dplyr)
library(survival)
library(tidyr)
library(boot)
library(ggplot2)


```

## Read in the data

To perform survival analyses, patient level data is required for the survival endpoints. 

This example uses a standard simulated data set
(adtte). There is no standard naming that is
needed for this package however, there are some set variables that are needed:

* Time - a numeric variable
* Event - a binary variable (event=1, censor=0)
* Treatment - a character variable with the name of the intervention treatment 

The data must be in "wide" format such that there is one row per patient and columns for each endpoint separately.
In this example, we use overall survival (OS) and progression-free survival (PFS). 
```{r}


# simulate data with a medium correlation between PFS & OS on the patient level
adtte <- sim_adtte(seed = 2020, rho = 0.6) 

# subset OS data and rename
OS_data <- adtte %>%
  filter(PARAMCD=="OS") %>%
  transmute(USUBJID,
            ARMCD,
            OS_days = AVAL,
            OS_event = 1- CNSR
  )

# subset PFS data and rename
PFS_data <- adtte %>%
  filter(PARAMCD=="PFS") %>%
  transmute(USUBJID,
            ARMCD,
            PFS_days = AVAL,
            PFS_event = 1- CNSR
  )

analysis_data <- left_join(OS_data, PFS_data, by = c("USUBJID", "ARMCD"))


```


# Bootstrapping the endpoints

## Ignoring correlation between endpoints

Bootstrapping has been used to estimate the uncertainty of the parameters from the survival models for multiple endpoints at once to preserve the correlation between endpoints. In this example we have used OS and PFS. For speed of execution and illustration of concept we only fit a common shape weibull model for PFS and separate gamma models for OS here but all models discussed in <tt>runPSM</tt> could be specified with a single call.


```{r}


set.seed(2358)
n.sim <- 100

PSM_bootstraps_PFS <- boot(
  statistic = bootPSM, # bootstrap function
  R=n.sim, # number of bootstrap samples
  data=analysis_data,
  time_var="PFS_days",
  event_var="PFS_event",
  model.type=c("Common shape"),
  distr = c('weibull'),
  strata_var = "ARMCD",
  int_name="B",
  ref_name = "A"
)

PSM_bootstraps_OS <- boot(
  statistic = bootPSM, # bootstrap function
  R=n.sim, # number of bootstrap samples
  data=analysis_data,
  time_var="OS_days",
  event_var="OS_event",
  model.type=c("Separate"),
  distr = c('gamma'),
  strata_var = "ARMCD",
  int_name="B",
  ref_name = "A"
)


```

We can see these are using different bootstrap samples by looking at the bootstrap indexes. This is equiavlent to performing PSA for OS and PFS independently.

```{r}

index_PFS <- boot.array(PSM_bootstraps_PFS, indices = TRUE)
index_OS  <- boot.array(PSM_bootstraps_OS, indices = TRUE)

all(index_OS == index_PFS)

```


## Considering correlation between endpoints

If we want to maintain correlations between PFS and OS we need to use the same bootstrap samples for both the PFS and OS analysis. The easiest way to do this is to reuse the same seed before calling the boot function for the second endpoint. 


```{r}

n.sim <- 100

set.seed(2020)

PSM_bootstraps_PFScor <- boot(
  statistic = bootPSM, # bootstrap function
  R=n.sim, # number of bootstrap samples
  data=analysis_data,
  time_var="PFS_days",
  event_var="PFS_event",
  model.type=c("Common shape"),
  distr = c('weibull'),
  strata_var = "ARMCD",
  int_name="B",
  ref_name = "A"
)

set.seed(2020)

PSM_bootstraps_OScor <- boot(
  statistic = bootPSM, # bootstrap function
  R=n.sim, # number of bootstrap samples
  data=analysis_data,
  time_var="OS_days",
  event_var="OS_event",
  model.type=c("Separate"),
  distr = c('gamma'),
  strata_var = "ARMCD",
  int_name= "B",
  ref_name = "A"
)

```

We can check these are indeed using the same bootstrap samples by comparing the indexes selected. This means the associated bootstrap distributions for PFS and OS remain correlated.

```{r}

index_PFScor <- boot.array(PSM_bootstraps_PFScor, indices = TRUE)
index_OScor  <- boot.array(PSM_bootstraps_OScor, indices = TRUE)

all(index_OScor == index_PFScor)

```


## Plotting impact of accounting for correlations between endpoints

The primary use of the bootstrap samples is to be used in probabilistic sensitivity analyses (PSA) in economic models. To illustrate the impact of accounting for correlations between each endpoint in such PSA we will look at plotting the difference between the extrapolated mean PFS and mean OS. To do this we need to calculate the mean PFS and mean OS for the reference and intervention arm for each sample. 

```{r}

os_means <- bind_rows(
  mutate(bootPSMtidy(PSM_bootstraps_OS), Bootstrap = "Uncorrelated"), 
  mutate(bootPSMtidy(PSM_bootstraps_OScor), Bootstrap = "Correlated")
  ) %>%
  transmute(SampleID, Bootstrap, 
    os_mean_time_ref = flexsurv::mean_gamma(shape = gamma.shape.ref, rate = gamma.rate.ref),
    os_mean_time_int = flexsurv::mean_gamma(shape = gamma.shape.int, rate = gamma.rate.int),
    os_mean_delta = os_mean_time_int - os_mean_time_ref
  ) 

pfs_means <- bind_rows(
  mutate(bootPSMtidy(PSM_bootstraps_PFS), Bootstrap = "Uncorrelated"), 
  mutate(bootPSMtidy(PSM_bootstraps_PFScor), Bootstrap = "Correlated")
  ) %>%
  transmute(SampleID, Bootstrap, 
            pfs_mean_time_ref = flexsurv::mean_weibull(shape = weibull.shape.ref, scale = weibull.scale.ref),
            pfs_mean_time_int = flexsurv::mean_weibull(shape = weibull.shape.int, scale = weibull.scale.int),
            pfs_mean_delta = pfs_mean_time_int - pfs_mean_time_ref
  ) 


mean_durations <- pfs_means %>%
  left_join(os_means, by = c("SampleID", "Bootstrap"))

head(mean_durations)
```

We can now plot this dataset and as expected the correlated bootstrap approach leads to mean estimates for PFS and OS that preserve the correlations in the underlying data. Here we use all bootstrap samples but in the context of an excel economic we would perform PSA by randomly sampling SampleIDs and using the same SampleID for both PFS and OS in a single PSA run.

```{r}

mean_durations %>% 
  ggplot(aes(x = pfs_mean_delta, y = os_mean_delta, color = Bootstrap)) +
  theme_bw() +
  geom_point() +
  stat_ellipse() +
  coord_cartesian(xlim = c(100, 300), ylim = c(0, 2500)) +
  xlab("Difference in mean (weibull) PFS (B vs A)") +
  ylab("Difference in mean (gamma) OS (B vs A)") +
  ggtitle("Each point is a bootstrap sample")


```

#References
